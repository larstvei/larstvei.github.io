<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="nb" xml:lang="nb">
<head>
<!-- 2023-10-20 Fri 18:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hashing</title>
<meta name="author" content="Lars Tveito" />
<meta name="generator" content="Org Mode" />
<script type="text/javascript" src="js/script.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css" integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">
<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js" integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb" crossorigin="anonymous"></script>

<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<link rel="stylesheet" type="text/css" href="Rethink/rethink.css" />
</head>
<body>
<div id="preamble" class="status">
<h1 class="title">Hashing</h1>
                                                  <p class="author">Lars Tveito</p>
                                                  <p class="date">Høst 2023</p>
</div>
<div id="content" class="content">
<p>
Blant de mest effektive og anvendelige datastrukturene er basert på en teknikk
som heter <i>hashing</i>. Dersom du bruker <code>HashMap</code> eller <code>HashSet</code> i Java, eller
bruker <code>dict</code> eller <code>set</code> i Python så bruker du datastrukturer som er basert på
hashing. I likhet med binære søketrær støtter disse datastrukturene innsetting,
oppslag og sletting av nøkler, som assosieres til verdier. Vi skal lære hvordan
slike datastrukturer som kan implementeres enda mer effektivt.
</p>

<p>
Hashing kan brytes opp i tre problemer:
</p>
<ol class="org-ol">
<li>Gjøre en vilkårlig verdi om til et tall som brukes som en indeks.</li>
<li>Hvordan håndtere to verdier som får samme indeks.</li>
<li>Opprettholde en ideell størrelse på arrayet.</li>
</ol>

<p>
Vi skal se at vi oppnår det som kalles <i>amortisert</i> (eng: amortized) konstant
tid på samtlige operasjoner.
</p>

<div id="outline-container-org603c87b" class="outline-2">
<h2 id="org603c87b">Map</h2>
<div class="outline-text-2" id="text-org603c87b">
<p>
Et map, eller en mapping, er en abstrakt datatype. Helt generelt assosierer
en nøkkel \(k\) med nøyaktig én verdi \(v\).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" width="95%">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./map1.svg" alt="map1.svg" class="org-svg" /></td>
<td class="org-left"><img src="./map2.svg" alt="map2.svg" class="org-svg" /></td>
</tr>
</tbody>
</table>

<p>
Den abstrakte datatypen for map krever at vi kan sette inn, slå opp og slette
elementer. Dette kan oppnås med lineær tid på alle operasjoner dersom vi
implementerer et map ved hjelp av ordinære lenkede lister, der hvert element
i listen er et par \((k, v)\). Vi har sett at binære søketrær kan gi oss
logaritmisk tid på samtlige operasjoner, dersom vi antar at nøklene er totalt
ordnet. Ved hjelp av hashing kan vi gjøre disse operasjonene enda raskere.
</p>

<p>
Det er verdt å merke seg at vi kan implementere mengder som maps, der hver
nøkkel mapper til en vilkårlig verdi (for eksempel <code>null</code>).
</p>
</div>

<div id="outline-container-orgfb82cce" class="outline-3">
<h3 id="orgfb82cce">Hashmaps</h3>
<div class="outline-text-3" id="text-orgfb82cce">
<p>
Et hashmap er en måte å materialisere den abstrakte datatypen map. Vi bruker
kun et enkelt array \(A\), sammen med en <i>hashfunksjon</i> \(h\). Hashfunksjonen
konverterer en nøkkel \(k\) til et tall \(i\) der \(0 \leq i < |A|\). Vi kaller en
slik konvertering «å hashe».
</p>

<p>
Som regel finnes det utrolig mange <i>mulige</i> nøkler. Det finnes for eksempel
uendelig mange forskjellige strenger. Det er umulig å koke uendelig mange
ting ned til \(|A|\) tall, uansett hva størrelsen på \(A\) er. Derfor er vi
bundet til å få <i>kollisjoner</i>, altså at to ulike nøkler blir konvertert til
det samme tallet \(i\). Vi skal se på to måter å håndtere kollisjoner på.
</p>
</div>
</div>
</div>

<div id="outline-container-org8817199" class="outline-2">
<h2 id="org8817199">Hashfunksjoner</h2>
<div class="outline-text-2" id="text-org8817199">
<p>
En <i>funksjon</i> returner samme output for et gitt input <i>hver gang</i>.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> En
hashfunksjon \(h\) får en nøkkel \(k\) og et positivt heltall \(N\) som input, og
returnerer et positivt heltall slik at \(0 \leq h(k, N) < N\). Kravene til
denne funksjonen er:
</p>
<ul class="org-ul">
<li>Den må være <i>konsistent</i> (altså være en <i>funksjon</i>). Det vil si at samme
input gir <i>alltid</i> samme output.</li>
<li>Den må gi få <i>kollisjoner</i> (altså være godt distribuert). Det vil si at
ulike input bør hashe til ulike output så ofte som mulig.</li>
</ul>

<p>
Det vi ønsker er en funksjon som oppfører seg <i>tilsynelatende</i> tilfeldig
(altså som et kall på <code>random</code>), men som garanterer samme svar hver gang.
Ulike datastrukturer kan trenge egne hashfunksjoner. For heltall er det
ganske enkelt; et tall hasher til seg selv. For strenger må vi tenke litt
hardere.
</p>
</div>

<div id="outline-container-org50ab13f" class="outline-3">
<h3 id="org50ab13f">Hashfunksjon for strenger</h3>
<div class="outline-text-3" id="text-org50ab13f">
<blockquote>
<p>
Kodeblokkene er skjult, men vises når du trykker på dem; det er ment som en
oppfordring til å prøve å løse problemet selv først!
</p>

Trykk <a style="cursor: pointer;" onClick="unblurAll()">her</a> dersom du vil
vise alle kodeblokkene.
</blockquote>

<p>
Vi skal se på to mulige hashfunksjoner for strenger, for å illustrere
viktigheten av å velge en fornuftig hashfunksjon. Den første utfordringen er
å koke strengen ned til et tall mellom \(0\) og \(N\). Den underliggende
representasjonen av en streng er et array av positive heltall, der hvert
heltall representerer en bokstav. I Python kan vi hente ut de underliggende
tallene ved å kalle på <code>ord</code>. Her er et eksempel:
</p>

<div class="org-src-container">
<pre class="src src-python">[<span style="color: #673AB7;">ord</span>(c) <span style="color: #673AB7;">for</span> c <span style="color: #673AB7;">in</span> <span style="color: #90A4AE;">'algorithm'</span>]
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">97</td>
<td class="org-right">108</td>
<td class="org-right">103</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">105</td>
<td class="org-right">116</td>
<td class="org-right">104</td>
<td class="org-right">109</td>
</tr>
</tbody>
</table>

<p>
Altså er <code>a</code> assosiert med tallet \(97\), <code>l</code> er assosiert med tallet \(108\) og
så videre. Det viktige her er ikke hvilke bokstaver som er assosiert med
hvilke tall, men at for alle bokstaver så det <i>finnes</i> det et tall bokstaven
er assosiert med.
</p>

<p>
En rimelig (men kanskje litt naiv) hashfunksjon for strenger er å ta summen
av tallene bokstavene er assosiert med. For at tallet skal holde seg mellom
\(0\) og \(N\) gir vi summen modulo \(N\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">hash_string_bad</span>(s, N):
    <span style="color: #673AB7;">return</span> <span style="color: #673AB7;">sum</span>(<span style="color: #673AB7;">ord</span>(c) <span style="color: #673AB7;">for</span> c <span style="color: #673AB7;">in</span> s) % N
</pre>
</div>

<p>
Dette er en gyldig hashfunksjon, men allikevel er den ikke veldig bra i
praksis. Dette kommer delevis av at menneskeskapt data har en tendens til å
inneholde symmetrier som gjenspeiles i summen av bokstavene. En annen grunn
til at den ikke egner seg er at summen ikke vokser raskt nok; bare svært
lange strenger kan hashe til store tall.
</p>

<p>
Her er en bedre hashfunksjon for strenger, som er den som brukes i <a href="https://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/String.java#l1432">Java</a>.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">hash_string_good</span>(s, N):
    <span style="color: #263238; font-weight: bold;">h</span> = 0
    <span style="color: #673AB7;">for</span> c <span style="color: #673AB7;">in</span> s:
        <span style="color: #263238; font-weight: bold;">h</span> = 31 * h + <span style="color: #673AB7;">ord</span>(c)
    <span style="color: #673AB7;">return</span> h % N
</pre>
</div>

<p>
Den eneste forskjellen er at vi ganger den foreløpige hashen med \(31\) i hver
iterasjon. Dette gjør at permutasjoner ikke lenger hasher til det samme
elementet, og at tallet vokser veldig fort. Det er ikke noe veldig spesielt
med tallet \(31\), men det er stort nok til at selv ganske korte strenger kan
få rimelig store tall, det er et primtall, og det får plass i en byte.
</p>
</div>

<div id="outline-container-org3d0c5ba" class="outline-4">
<h4 id="org3d0c5ba">Sammenligning av hashfunksjoner</h4>
<div class="outline-text-4" id="text-org3d0c5ba">
<blockquote>
<p>
Merk at denne seksjonen viser hvordan vi kan illustrere hvor godt en
hashfunksjon distribuerer. Måten vi lager illustrasjonene og bibliotekene
som brukes er ikke relevant for pensum i IN2010, men tas med for å gi et
komplett bilde av hva de resulterende illustrasjonene viser.
</p>
</blockquote>

<p>
La oss forsøke å illustrere forskjellen mellom disse to hashfunksjonene ved
å undersøke hvor mange kollisjoner som forekommer ved bruk av henholdsvis
<code>hash_string_bad</code> og <code>hash_string_good</code> på et stort datasett. Vi kan ta
utgangspunkt i en ordliste som brukes av mange stavekontrollprogrammer og
ligger lett tilgjengelig i <code>/usr/share/dict/words</code> på de fleste
unix-systemer.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">with</span> <span style="color: #673AB7;">open</span>(<span style="color: #90A4AE;">'/usr/share/dict/words'</span>, <span style="color: #90A4AE;">'r'</span>) <span style="color: #673AB7;">as</span> f:
    <span style="color: #263238; font-weight: bold;">words</span> = [line.strip() <span style="color: #673AB7;">for</span> line <span style="color: #673AB7;">in</span> f]
</pre>
</div>

<p>
Vi kan raskt sjekke hvor mange ord som ligger i ordlisten:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">len</span>(words)
</pre>
</div>

<pre class="example">
235976
</pre>


<p>
Nå kan vi skrive en prosedyre som anvender en gitt hashfunksjon \(h\) med
tilhørende \(N\) på alle strengene i en liste av strenger. Den returnerer en
mapping fra posisjoner \(0 \leq i < N\) til antall strenger \(s\) i listen som
hasher til \(i\). Vi kaller dette distribusjonen for hashfunksjonen \(h\). For
å gjøre dette kan vi benytte oss av Python's <a href="https://docs.python.org/3/library/collections.html#collections.Counter"><code>Counter</code></a> datastruktur.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">from</span> collections <span style="color: #673AB7;">import</span> Counter

<span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">hash_distribution</span>(hashfn, N, strings):
    <span style="color: #673AB7;">return</span> Counter([hashfn(s, N) <span style="color: #673AB7;">for</span> s <span style="color: #673AB7;">in</span> strings])
</pre>
</div>

<p>
Vi kan vi lage en bitteliten tabell som viser hvordan hashfunksjonene
distribuerer for \(N = 7\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #263238; font-weight: bold;">dist_bad</span> = hash_distribution(hash_string_bad, 7, words)
<span style="color: #263238; font-weight: bold;">dist_good</span> = hash_distribution(hash_string_good, 7, words)
<span style="color: #263238; font-weight: bold;">header</span> = [<span style="color: #90A4AE;">'i'</span>, <span style="color: #90A4AE;">'bad'</span>, <span style="color: #90A4AE;">'good'</span>]
<span style="color: #263238; font-weight: bold;">rows</span> = [[i, dist_bad[i], dist_good[i]] <span style="color: #673AB7;">for</span> i <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">range</span>(7)]
[header] + rows
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">i</td>
<td class="org-right">bad</td>
<td class="org-right">good</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">33949</td>
<td class="org-right">33904</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">33580</td>
<td class="org-right">33919</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">33785</td>
<td class="org-right">33359</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">33818</td>
<td class="org-right">33985</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">33577</td>
<td class="org-right">33556</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">33506</td>
<td class="org-right">33678</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">33761</td>
<td class="org-right">33575</td>
</tr>
</tbody>
</table>

<p>
Hvis vi ser på antall strenger (\(235976\)) og deler det på \(N\) får vi
\(\frac{235976}{7} = 33710\); det forteller oss at med en perfekt
distribusjon ville alle posisjoner blitt hashet til \(33710\) ganger. Vi kan
se at begge hashfunksjonene gir en ganske god distribusjon. For å få en
bedre innsikt trenger vi å se på langt større \(N\), og da kan det være
hensiktsmessig å lage en illustrasjon. Her bruker vi et enkelt bibliotek
<a href="https://pypi.org/project/svgwrite/">svgwrite</a> for å lage <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a>-filer.
</p>
</div>
</div>

<div id="outline-container-orgc573dff" class="outline-4">
<h4 id="orgc573dff">Lag illustrasjoner</h4>
<div class="outline-text-4" id="text-orgc573dff">
<p>
La oss anta at \(N\) er et kvadrattall der \(s^2 = N\). Da kan vi lage et \(s
    \times s\) bilde, der hvert punkt svarer til en posisjon \(i\). Gitt to
positive heltall \(0 \leq x < s\) og \(0 \leq y < s\), så svarer \(x + y \cdot
    s\) til en unik posisjon \(i\) (dette er en vanlig måte å konvertere mellom 1-
og 2-dimensjonale arrayer). Vi lar hvert punkt fargelegges med styrke som
er proporsjonal med hvor mange strenger som hasher til \(k\). Hvert punkt
tegnes som en sirkel med radius \(r = \frac{1}{2}\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">import</span> svgwrite
<span style="color: #673AB7;">from</span> svgwrite.shapes <span style="color: #673AB7;">import</span> Circle

<span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">draw_distribution</span>(dist, N):
    <span style="color: #263238; font-weight: bold;">s</span> = <span style="color: #673AB7;">int</span>(N**0.5)
    <span style="color: #263238; font-weight: bold;">r</span> = 0.5
    <span style="color: #263238; font-weight: bold;">svg</span> = svgwrite.Drawing(size=(s, s))
    svg.viewbox(0, 0, s, s)
    <span style="color: #263238; font-weight: bold;">m</span> = dist.most_common(1)[0][1]
    <span style="color: #673AB7;">for</span> y <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">range</span>(s):
        <span style="color: #673AB7;">for</span> x <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">range</span>(s):
            <span style="color: #263238; font-weight: bold;">k</span> = x + y * s
            <span style="color: #263238; font-weight: bold;">opacity</span> = dist[k]/m
            svg.add(Circle((x + r, y + r), r,
                           fill = <span style="color: #90A4AE;">'purple'</span>,
                           fill_opacity = opacity))
    <span style="color: #673AB7;">return</span> svg
</pre>
</div>

<p>
Nå kan vi tegne distribusjoner for den dårlige og den gode hashfunksjonen,
og se hvordan de sammenlignes for ulike verdier av \(N\). Vi skriver en liten
hjelpefunksjon for dette.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">drawhashfunctions</span>(Ns, hashfunctions, strings):
    <span style="color: #673AB7;">for</span> N <span style="color: #673AB7;">in</span> Ns:
        <span style="color: #673AB7;">for</span> hashfn <span style="color: #673AB7;">in</span> hashfunctions:
            <span style="color: #263238; font-weight: bold;">name</span> = hashfn.<span style="color: #673AB7;">__name__</span> + <span style="color: #90A4AE;">'_'</span> + <span style="color: #673AB7;">str</span>(N) + <span style="color: #90A4AE;">'.svg'</span>
            <span style="color: #263238; font-weight: bold;">dist</span> = hash_distribution(hashfn, N, strings)
            <span style="color: #263238; font-weight: bold;">svg</span> = draw_distribution(dist, N)
            svg.saveas(name)
</pre>
</div>

<p>
Vi kan kalle på denne for rimelige verdier av \(N\) og hashfunksjonene vi
ønsker å vise.
</p>

<div class="org-src-container">
<pre class="src src-python">drawhashfunctions([100, 400, 1024, 2500, 4096],
                  [hash_string_bad, hash_string_good],
                  words)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd00fac" class="outline-4">
<h4 id="orgbd00fac">Resultater</h4>
<div class="outline-text-4" id="text-orgbd00fac">
<p>
For \(N = 100\) kan vi allerede se at det er større variasjon i distribusjonen
for <code>hash_string_bad</code> enn <code>hash_string_good</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" width="95%">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./hash_string_bad_100.svg" alt="hash_string_bad_100.svg" class="org-svg" /></td>
<td class="org-left"><img src="./hash_string_good_100.svg" alt="hash_string_good_100.svg" class="org-svg" /></td>
</tr>
</tbody>
</table>

<p>
For \(N = 400\) blir forskjellen noe mer markant.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" width="95%">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./hash_string_bad_400.svg" alt="hash_string_bad_400.svg" class="org-svg" /></td>
<td class="org-left"><img src="./hash_string_good_400.svg" alt="hash_string_good_400.svg" class="org-svg" /></td>
</tr>
</tbody>
</table>

<p>
For \(N = 1024\) ser vi helt tydelig at det hashes til noen nøkler mye oftere
enn andre for <code>hash_string_bad</code>, men det er ingen slike mønstre for
<code>hash_string_good</code>.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" width="95%">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./hash_string_bad_1024.svg" alt="hash_string_bad_1024.svg" class="org-svg" /></td>
<td class="org-left"><img src="./hash_string_good_1024.svg" alt="hash_string_good_1024.svg" class="org-svg" /></td>
</tr>
</tbody>
</table>

<p>
For \(N = 2500\) kan vi identifisere nytt problem med <code>hash_string_bad</code>. Ingen
ord hasher til et tall som blir større enn \(N\) (før vi anvender modulo), og
dermed er det mange nøkler som aldri hashes til. Det vil resultere i ubrukte
plasser i et array som brukes for a representere et hashmap.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" width="95%">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./hash_string_bad_2500.svg" alt="hash_string_bad_2500.svg" class="org-svg" /></td>
<td class="org-left"><img src="./hash_string_good_2500.svg" alt="hash_string_good_2500.svg" class="org-svg" /></td>
</tr>
</tbody>
</table>

<p>
Til slutt kan vi se for \(N = 4096\) at problemet vedvarer for den dårlige
hashfunksjonen, men den gode fortsetter å gi en jevn distribusjon.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" width="95%">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left"><img src="./hash_string_bad_4096.svg" alt="hash_string_bad_4096.svg" class="org-svg" /></td>
<td class="org-left"><img src="./hash_string_good_4096.svg" alt="hash_string_good_4096.svg" class="org-svg" /></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div id="outline-container-org313dccf" class="outline-2">
<h2 id="org313dccf">Kollisjonshåndtering</h2>
<div class="outline-text-2" id="text-org313dccf">
<p>
Den overordnede idéen for å implementere en hashmap er å la hashmapet være
representert som et array \(A\) av størrelse \(N\), og bruke en hashfunksjon
\(h(k, N)\) til å angi indeksen for en gitt nøkkel \(k\). Selv hvis vi lar \(N\)
være mye større enn antall elementer \(n\) som er lagret i hashmapet, så vil
det kunne oppstå kollisjoner (altså to nøkler som sogner til samme indeks).
Vi skal se to måter å håndtere slike konflikter på. Den ene går ut på å la
hver posisjon i arrayet peke til en <i>liste</i> av nøkkel- og verdipar \((k, v)\).
Denne teknikken kalles «separate chaining». Den andre teknikken går ut på å
først forsøke å plassere \((k, v)\) på indeksen som er gitt av hashfunksjonen;
dersom det ikke er ledig på den plassen, så prøver vi neste plass, og neste
helt frem til vi finner en ledig plass. Denne teknikken kalles «linear
probing».
</p>

<p>
Felles for begge teknikkene er at effektiviteten blir svært dårlig dersom det
oppstår <i>mange</i> kollisjoner. I det ekstreme (og helt usannsynlige) tilfellet
der alle nøkler hasher til samme posisjon, så får vi lineær tid på alle
operasjoner. Dette håndteres ved å sørge for at det til enhver tid er godt
med plass i arrayet. Hvis \(n\) er antall elementer som lagres, og \(N\) er
størrelsen på arrayet, så gir \(\frac{n}{N}\) det vi kaller en <i>load factor</i>.
En vanlig strategi for å sørge for at det alltid er godt med plass er å doble
størrelsen på arrayet når \(\frac{n}{N}\) overstiger \(0.75\).
</p>

<p>
Vi kan lage en klasse <code>MyMap</code> som inneholder oppførselen som er felles for
begge varianter. Den eksponerer en metode <code>ensurecapacity</code>, som dobler
størrelsen på arrayet dersom det er for fullt. En slik størrelsesendring
kalles en <i>rehash</i>, fordi alle nøkler må hashes på nytt med hensyn til en
større \(N\), og plasseres tilbake i arrayet.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">class</span> <span style="color: #673AB7;">MyMap</span>:
    <span style="color: #263238; font-weight: bold;">LOAD_FACTOR_THRESHOLD</span> = 0.75

    <span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__init__</span>(<span style="color: #673AB7;">self</span>):
        <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">n</span> = 0
        <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">N</span> = 1
        <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span> = [<span style="color: #673AB7;">None</span>] * <span style="color: #673AB7;">self</span>.N

    <span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__loadfactor</span>(<span style="color: #673AB7;">self</span>):
        <span style="color: #673AB7;">return</span> <span style="color: #673AB7;">self</span>.n / <span style="color: #673AB7;">self</span>.N

    <span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__rehash</span>(<span style="color: #673AB7;">self</span>):
        <span style="color: #263238; font-weight: bold;">kvs</span> = [(k, v) <span style="color: #673AB7;">for</span> k, v <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">self</span>]
        <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">n</span> = 0
        <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">N</span> *= 2
        <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span> = [<span style="color: #673AB7;">None</span>] * <span style="color: #673AB7;">self</span>.N
        <span style="color: #673AB7;">for</span> k, v <span style="color: #673AB7;">in</span> kvs:
            <span style="color: #673AB7;">self</span>[k] = v

    <span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">ensurecapacity</span>(<span style="color: #673AB7;">self</span>):
        <span style="color: #673AB7;">if</span> <span style="color: #673AB7;">self</span>.__loadfactor() &gt;= <span style="color: #673AB7;">self</span>.LOAD_FACTOR_THRESHOLD:
            <span style="color: #673AB7;">self</span>.__rehash()

    <span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__repr__</span>(<span style="color: #673AB7;">self</span>):
        <span style="color: #263238; font-weight: bold;">kv_strs</span> = [f<span style="color: #90A4AE;">'</span>{k}<span style="color: #90A4AE;"> &#8614; </span>{v}<span style="color: #90A4AE;">'</span> <span style="color: #673AB7;">for</span> k, v <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">self</span>]
        <span style="color: #673AB7;">return</span> <span style="color: #90A4AE;">'{'</span> + <span style="color: #90A4AE;">', '</span>.join(kv_strs) + <span style="color: #90A4AE;">'}'</span>
</pre>
</div>

<p>
Merk at vi her antar at vi også implementerer en iterator for klassene som
arver fra <code>MyMap</code> (i Java ville <code>MyMap</code> vært implementert som en abstrakt
klasse, som hadde vært noe bedre objektorientert stil). Vi implementerer også
<code>__repr__</code>, som får Python til å printe vår implementasjon av hashmap på et
mer lesbart format.
</p>

<p>
I implementasjonene under vil vi bruke Python sin innebygde hashfunksjon
<code>hash</code>, som fungerer på (nesten<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>) alle typer i Python, til fordel for de
som ble implementert i forrige seksjon. Denne returnerer et tall uten hensyn
til \(N\), så vi må selv ta modulo \(N\) av resultatet.
</p>
</div>
</div>

<div id="outline-container-org68003cd" class="outline-2">
<h2 id="org68003cd">Separate Chaining</h2>
<div class="outline-text-2" id="text-org68003cd">
<p>
Husk at idéen er å la hver posisjon i arrayet peke til en liste, og plassere
nøkkel-/​verdiparene i den listen. Lister i denne konteksten kalles ofte
<i>bøtter</i>. I stedet for å opprette mange tomme lister, lar vi heller hver
posisjon i arrayet peke på <code>None</code>, og opprette en liste ved behov. Dersom
det allerede finnes en verdi med samme nøkkel, så skal vi erstatte verdien.
</p>

<p>
La oss lage et skall for et hashmap basert på separate chaining.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org5ee8de4"><span style="color: #673AB7;">class</span> <span style="color: #673AB7;">SeparateChainingMap</span>(MyMap):

    &lt;&lt;separate_chaining_insert&gt;&gt;


    &lt;&lt;separate_chaining_get&gt;&gt;


    &lt;&lt;separate_chaining_delete&gt;&gt;


    &lt;&lt;separate_chaining_iter&gt;&gt;
</pre>
</div>

<p>
Syntaksen eksemplifisert ved <code>&lt;&lt;separate_chaining_insert&gt;&gt;</code> brukes som
plassholder for kodeblokker vi skal skrive. Metodene kommer i de neste
delseksjonene, og siste delseksjon for separate chaining inneholder den
fulle implementasjonen.
</p>
</div>

<div id="outline-container-org9b0e1aa" class="outline-4">
<h4 id="org9b0e1aa">Innsetting</h4>
<div class="outline-text-4" id="text-org9b0e1aa">
<p>
For innsetting av et nøkkel-/verdipar \((k, v)\) er strategien som følger:
</p>
<ul class="org-ul">
<li>Passe på at det er nok plass (kalle på <code>ensurecapacity</code>).</li>
<li>Finne indeksen \(i\) hvor nøkkel-/verdiparet skal plasseres.</li>
<li>Sørge for at det er en bøtte vi kan putte nøkkel-/verdiparet i.</li>
<li>Erstatte verdien hvis det er aktuelt.</li>
<li>Legg til nøkkel-/verdiparet hvis nøkkelen ikke var i hashmapet fra før.</li>
</ul>

<p>
Ved å kalle metoden <code>__setitem__</code>, så kan vi bruke Python sin <code>d[k] = v</code>
syntaks, der <code>d</code> er en ordbok (eller i vårt tilfelle, en
<code>SeparateChainingMap</code>).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org927443c"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__setitem__</span>(<span style="color: #673AB7;">self</span>, k, v):
    <span style="color: #673AB7;">self</span>.ensurecapacity()

    <span style="color: #263238; font-weight: bold;">i</span> = <span style="color: #673AB7;">hash</span>(k) % <span style="color: #673AB7;">self</span>.N

    <span style="color: #673AB7;">if</span> <span style="color: #673AB7;">self</span>.A[i] == <span style="color: #673AB7;">None</span>:
        <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span>[i] = []

    <span style="color: #263238; font-weight: bold;">bucket</span> = <span style="color: #673AB7;">self</span>.A[i]

    <span style="color: #673AB7;">for</span> j <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">range</span>(<span style="color: #673AB7;">len</span>(bucket)):
        <span style="color: #263238; font-weight: bold;">kj</span>, <span style="color: #263238; font-weight: bold;">vj</span> = bucket[j]
        <span style="color: #673AB7;">if</span> kj == k:
            <span style="color: #263238; font-weight: bold;">bucket</span>[j] = (k, v)
            <span style="color: #673AB7;">return</span>

    <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">n</span> += 1
    bucket.append((k, v))
</pre>
</div>
</div>
</div>

<div id="outline-container-org378a9a9" class="outline-4">
<h4 id="org378a9a9">Oppslag</h4>
<div class="outline-text-4" id="text-org378a9a9">
<p>
Å finne verdien for en gitt nøkkel \(k\) i hashmapet følger i stor grad samme
fremgangsmåte som innsetting, men er litt enklere. Vi finner bøtta \(k\) skal
være i, og leter gjennom den. Dersom vi finner nøkkelen \(k\) skal den
korresponderende verdien returneres.
</p>

<p>
Ved å kalle metoden <code>__getitem__</code>, så kan vi bruke Python sin <code>d[k]</code>
syntaks.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org7227d54"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__getitem__</span>(<span style="color: #673AB7;">self</span>, k):
    <span style="color: #263238; font-weight: bold;">i</span> = <span style="color: #673AB7;">hash</span>(k) % <span style="color: #673AB7;">self</span>.N
    <span style="color: #263238; font-weight: bold;">bucket</span> = <span style="color: #673AB7;">self</span>.A[i]

    <span style="color: #673AB7;">if</span> bucket == <span style="color: #673AB7;">None</span>:
        <span style="color: #673AB7;">return</span>

    <span style="color: #673AB7;">for</span> ki, v <span style="color: #673AB7;">in</span> bucket:
        <span style="color: #673AB7;">if</span> ki == k:
            <span style="color: #673AB7;">return</span> v
</pre>
</div>
</div>
</div>

<div id="outline-container-org5de6b06" class="outline-4">
<h4 id="org5de6b06">Sletting</h4>
<div class="outline-text-4" id="text-org5de6b06">
<p>
Igjen er det mye likt for sletting. Vi finner riktig bøtte for en gitt
nøkkel \(k\), og sletter \((k, v)\) fra listen. Her gjøres dette ved hjelp av
en <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">list comprehension</a>.
</p>

<p>
Ved å kalle metoden <code>__delitem__</code>, så kan vi bruke Python sin <code>del d[k]</code>
syntaks.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org4f2e2dc"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__delitem__</span>(<span style="color: #673AB7;">self</span>, k):
    <span style="color: #263238; font-weight: bold;">i</span> = <span style="color: #673AB7;">hash</span>(k) % <span style="color: #673AB7;">self</span>.N
    <span style="color: #263238; font-weight: bold;">bucket</span> = <span style="color: #673AB7;">self</span>.A[i]

    <span style="color: #673AB7;">if</span> bucket == <span style="color: #673AB7;">None</span>:
        <span style="color: #673AB7;">return</span>

    <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span>[i] = [(ki, v) <span style="color: #673AB7;">for</span> ki, v <span style="color: #673AB7;">in</span> bucket <span style="color: #673AB7;">if</span> ki != k]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgffd648c" class="outline-4">
<h4 id="orgffd648c">Iterator</h4>
<div class="outline-text-4" id="text-orgffd648c">
<p>
Iteratoren for hashmapet kan skrives ved å gå gjennom arrayet, og gå
gjennom hver (ikke-tomme) bøtte, og gi hvert nøkkel-/verdipar. For å få en
iterator bruker vi <code>yield</code>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org95e3a16"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__iter__</span>(<span style="color: #673AB7;">self</span>):
    <span style="color: #673AB7;">for</span> bucket <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">self</span>.A:
        <span style="color: #673AB7;">if</span> bucket:
            <span style="color: #673AB7;">for</span> kv <span style="color: #673AB7;">in</span> bucket:
                <span style="color: #673AB7;">yield</span> kv
</pre>
</div>
</div>
</div>

<div id="outline-container-org6abb8af" class="outline-4">
<h4 id="org6abb8af">Minitest</h4>
<div class="outline-text-4" id="text-org6abb8af">
<p>
La oss sjekke om dette hashmapet faktisk kan holde på elementer slik vi
forventer. Vi nøyer oss med å mappe bokstavene <code>a</code>, <code>b</code>, <code>c</code> og <code>d</code>, til
henholdsvis <code>1</code>, <code>2</code>, <code>3</code> og <code>4</code>, og printer ut hashmapet mellom hver
operasjon.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #263238; font-weight: bold;">d</span> = SeparateChainingMap()
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'a'</span>] = 0
<span style="color: #673AB7;">print</span>(d)
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'b'</span>] = 1
<span style="color: #673AB7;">print</span>(d)
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'c'</span>] = 2
<span style="color: #673AB7;">print</span>(d)
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'d'</span>] = 3
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'a'</span>]
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'b'</span>]
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'c'</span>]
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'d'</span>]
<span style="color: #673AB7;">print</span>(d)
</pre>
</div>

<pre class="example">
{a ↦ 0}
{b ↦ 1, a ↦ 0}
{b ↦ 1, c ↦ 2, a ↦ 0}
{b ↦ 1, c ↦ 2, a ↦ 0, d ↦ 3}
{b ↦ 1, c ↦ 2, d ↦ 3}
{c ↦ 2, d ↦ 3}
{d ↦ 3}
{}
</pre>


<p>
Det ser rimelig ut! Det er verdt å merke seg at elementene ikke kommer ut
sortert etter nøkkel. Det er forventet, siden hashmaps ikke er ordnede. 
</p>

<div class="collapsible" id="orge8e0892">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;separate_chaining_map&gt;&gt;
</pre>
</div>

</div>

<p>
Klikk på kodeblokken ovenfor for å se hele implementasjonen av hashmap med
separate chaining.
</p>
</div>
</div>
</div>

<div id="outline-container-org7fad5fd" class="outline-2">
<h2 id="org7fad5fd">Linear Probing</h2>
<div class="outline-text-2" id="text-org7fad5fd">
<p>
Idéen bak linear probing er å se på \(i = h(k, N)\) som den ideelle posisjonen
for en nøkkel \(k\), og hvis denne posisjonen er opptatt, så prøver vi neste
posisjon \(i + 1 \mod N\), og så neste helt frem vi når en ledig posisjon.
Merk at den siste posisjonen \(N - 1\) i arrayet sin neste er \(0\); vi modulo
\(N\) for å alltid sørge for at vi holder oss innenfor grensene av arrayet.
Når vi skal hente ut en verdi med nøkkel \(k\) vil vi igjen starte å lete på
posisjonen \(i = h(k, N)\). Dersom vi finner et nøkkel-/verdipar med \(k\) som
nøkkel kan vi returnere verdien \(v\). Dersom plassen er ledig kan vi
konkludere med at nøkkelen ikke er i hashmapet. Dersom vi finner en nøkkel
som er ulik \(k\), så kan vi lete videre på neste plass, og fortsette slik
frem til vi finner \(k\) (og i så fall returnerer verdien) eller vi finner en
ledig plass, og i så fall konkludere med at nøkkelen ikke er i hashmapet.
</p>

<p>
Både insetting og oppslag er egentlig ganske rett frem med linear probing.
Strategien med å starte på plass \(i = h(k, N)\) og lete etter neste frem til
vi finner \(k\) eller en ledig plass er i grunn litt naiv. Det fungerer fordi
at den eneste grunnen til at \(k\) ligger på en plass etter \(i\) er at det
allerede lå en verdi på plass \(i\) da \(k\) ble lagt til; hvis de elementene som
lå mellom \(i\) og der \(k\) ble lagt til fremdeles ligger der når vi skal søke
etter \(k\), så fungerer alt som det skal. Et problem oppstår dersom vi skulle
fjerne verdien som ligger på plass \(i\); da vil et oppslag på \(k\) avslutte,
fordi plass \(i\) er ledig. Det betyr at ved sletting, så er vi nødt til å
tette eventuelle «hull» som oppstår ved å fjerne et element. Vi ønsker å
tette hullet med det første nøkkel-/​verdiparene <i>etter</i> \(i\) som ville
blitt plassert på plass \(i\) dersom det ble plassert i hashmapet nå som plass
\(i\) er ledig. Det er nøyaktig de nøklene som \(k\) som hasher til en posisjon
\(i\) eller «tidligere». Vi vil konkretisere hva «tidligere» betyr når vi
jobber med modulo \(N\) i delseksjonen om sletting nedenfor.
</p>

<p>
<a href="https://larstvei.github.io/linear-probing/">Denne interaktive visualiseringen</a> kan hjelpe for å bygge intuisjon for
algoritmene for linear probing. Kort bruker-guide:
</p>
<ul class="org-ul">
<li>Implementasjonen viser et hashset (altså lagrer vi kun nøkler, og ikke
verdier).</li>
<li>Nøklene er heltall.</li>
<li>Hashfunksjonen som brukes er \(h(k, N) = k \mod N\).</li>
<li>Feltet <code>random</code> kan overskrives med et heltall.</li>
<li>Hver knapp operasjon har en én-bokstavs keybinding, indikert med en
<span class="underline">u</span>​nderstrek under bokstaven det gjelder.</li>
</ul>

<p>
La oss igjen lage et skall for et hashmap basert på linear probing. Den også
arver fra <code>MyMap</code>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org857f72a"><span style="color: #673AB7;">class</span> <span style="color: #673AB7;">LinearProbingMap</span>(MyMap):

    &lt;&lt;linear_probing_insert&gt;&gt;


    &lt;&lt;linear_probing_get&gt;&gt;


    &lt;&lt;linear_probing_delete&gt;&gt;


    &lt;&lt;linear_probing_fill_hole&gt;&gt;


    &lt;&lt;linear_probing_iter&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org9981840" class="outline-4">
<h4 id="org9981840">Innsetting</h4>
<div class="outline-text-4" id="text-org9981840">
<p>
For innsetting av et nøkkel-/verdipar \((k, v)\) er strategien som følger:
</p>
<ul class="org-ul">
<li>Passe på at det er nok plass (kalle på <code>ensurecapacity</code>).</li>
<li>Finne indeksen \(i\) hvor nøkkel-/verdiparet ideelt skal plasseres.</li>
<li>Finne den første ledige plassen fra \(i\), og plassere \((k, v)\).</li>
</ul>

<p>
Ledige plasser er indikert ved <code>None</code>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="org5147040"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__setitem__</span>(<span style="color: #673AB7;">self</span>, k, v):
    <span style="color: #673AB7;">self</span>.ensurecapacity()

    <span style="color: #263238; font-weight: bold;">i</span> = <span style="color: #673AB7;">hash</span>(k) % <span style="color: #673AB7;">self</span>.N

    <span style="color: #673AB7;">while</span> <span style="color: #673AB7;">self</span>.A[i] != <span style="color: #673AB7;">None</span>:
        <span style="color: #263238; font-weight: bold;">ki</span>, <span style="color: #263238; font-weight: bold;">_</span> = <span style="color: #673AB7;">self</span>.A[i]
        <span style="color: #673AB7;">if</span> k == ki:
            <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span>[i] = (k, v)
            <span style="color: #673AB7;">return</span>
        <span style="color: #263238; font-weight: bold;">i</span> = (i + 1) % <span style="color: #673AB7;">self</span>.N

    <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">n</span> += 1
    <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span>[i] = (k, v)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf36780a" class="outline-4">
<h4 id="orgf36780a">Oppslag</h4>
<div class="outline-text-4" id="text-orgf36780a">
<p>
Oppslag følger i stor grad samme fremgangsmåte som innsetting. Vi starter
på indeks \(i = h(k, N)\), sjekker om \(k\) ligger på plass \(i\). Hvis ikke,
øker vi \(i\) (modulo \(N\)) så lenge vi ikke møter på et hull (representert
ved <code>None</code>).
</p>

<div class="org-src-container">
<pre class="src src-python" id="org5d79e94"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__getitem__</span>(<span style="color: #673AB7;">self</span>, k):
    <span style="color: #263238; font-weight: bold;">i</span> = <span style="color: #673AB7;">hash</span>(k) % <span style="color: #673AB7;">self</span>.N

    <span style="color: #673AB7;">while</span> <span style="color: #673AB7;">self</span>.A[i] != <span style="color: #673AB7;">None</span>:
        <span style="color: #263238; font-weight: bold;">ki</span>, <span style="color: #263238; font-weight: bold;">vi</span> = <span style="color: #673AB7;">self</span>.A[i]
        <span style="color: #673AB7;">if</span> k == ki:
            <span style="color: #673AB7;">return</span> v
        <span style="color: #263238; font-weight: bold;">i</span> = (i + 1) % <span style="color: #673AB7;">self</span>.N
</pre>
</div>
</div>
</div>

<div id="outline-container-org4bf0280" class="outline-4">
<h4 id="org4bf0280">Sletting</h4>
<div class="outline-text-4" id="text-org4bf0280">
<p>
Igjen er strukturen mye av det samme. Vi må først finne nøkkelen \(k\),
akkurat slik vi gjorde for oppslag. Hvis vi finner \(k\), så setter vi
posisjonen i arrayet til <code>None</code>. Så kaller vi på <code>__fill_hole</code>, som
defineres nedenfor.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgb79f19c"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__delitem__</span>(<span style="color: #673AB7;">self</span>, k):
    <span style="color: #263238; font-weight: bold;">i</span> = <span style="color: #673AB7;">hash</span>(k) % <span style="color: #673AB7;">self</span>.N

    <span style="color: #673AB7;">while</span> <span style="color: #673AB7;">self</span>.A[i] != <span style="color: #673AB7;">None</span>:
        <span style="color: #263238; font-weight: bold;">ki</span>, <span style="color: #263238; font-weight: bold;">_</span> = <span style="color: #673AB7;">self</span>.A[i]
        <span style="color: #673AB7;">if</span> k == ki:
            <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">n</span> -= 1
            <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span>[i] = <span style="color: #673AB7;">None</span>
            <span style="color: #673AB7;">self</span>.__fill_hole(i)
            <span style="color: #673AB7;">return</span>
        <span style="color: #263238; font-weight: bold;">i</span> = (i + 1) % <span style="color: #673AB7;">self</span>.N
</pre>
</div>

<p>
Å «tette hullet» på plass \(i\) gjøres ved lete fra \(i + 1 \mod N\) frem til
vi treffer et nytt hull eller finner en nøkkel som kan flyttes til plass
\(i\). Dersom vi finner en slik nøkkel, så må vi rekursivt tette hullet som
oppstår når vi flytter nøkkelen til plass \(i\).
</p>

<p>
Det siste som gjenstår er å avgjøre om en nøkkel \(k\) kan flyttes til plass
\(i\). Dette er tilfellet dersom \(k\) hasher til plassen \(i\) <i>eller en
tidligere</i> posisjon. Anta at \(k\) ble funnet på posisjon \(i + s\), der \(s\) er
avstanden til \(i\). Vi kan flytte \(k\) dersom \(k\) <i>ikke</i> hasher til en verdi
mellom \(i+1\) og \(s\). Siden vi her regner med modulo er det ikke
tilstrekkelig å sjekke om \(h(k, N) \leq i\).
</p>

<div class="org-src-container">
<pre class="src src-python" id="orgf08bae1"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__fill_hole</span>(<span style="color: #673AB7;">self</span>, i):
    <span style="color: #263238; font-weight: bold;">s</span> = 1
    <span style="color: #673AB7;">while</span> <span style="color: #673AB7;">self</span>.A[(i + s) % <span style="color: #673AB7;">self</span>.N] != <span style="color: #673AB7;">None</span>:
        <span style="color: #263238; font-weight: bold;">k</span>, <span style="color: #263238; font-weight: bold;">v</span> = <span style="color: #673AB7;">self</span>.A[(i + s) % <span style="color: #673AB7;">self</span>.N]
        <span style="color: #263238; font-weight: bold;">j</span> = <span style="color: #673AB7;">hash</span>(k) % <span style="color: #673AB7;">self</span>.N
        <span style="color: #673AB7;">if</span> <span style="color: #673AB7;">not</span>(0 &lt; (j - i) % <span style="color: #673AB7;">self</span>.N &lt;= s):
            <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span>[i] = (k, v)
            <span style="color: #673AB7;">self</span>.<span style="color: #263238; font-weight: bold;">A</span>[(i + s) % <span style="color: #673AB7;">self</span>.N] = <span style="color: #673AB7;">None</span>
            <span style="color: #673AB7;">self</span>.__fill_hole((i + s) % <span style="color: #673AB7;">self</span>.N)
            <span style="color: #673AB7;">return</span>
        <span style="color: #263238; font-weight: bold;">s</span> += 1
</pre>
</div>

<p>
Linjen som inneholder testen <code>not(0 &lt; (j - i) % self.N &lt;= s)</code> er formulert
ganske annerledes i boken. Der står det heller \(j \not\in (i, i + s] \pmod
    N\), som betyr at \(j\) <i>ikke</i> er lik hverken \(i + 1 \pmod N, i + 2 \pmod N,
    \dots, i + s \pmod N\). Måten vi formulerer dette i koden er basert på
innsikten om at modulo aritmetikk fungerer som en klokke, så vi kan fint
«forskyve» alle tallene rundt sirkelen uten at forholdet mellom tallene
\(i\), \(j\) og \(s\) endrer seg. Hvis vi legger til \(N - i\) overalt har vi:
</p>

<p>
\[\begin{align*}
    i + (N - i) &= 0 &&\pmod N\\
    i + s + (N - i) &= s + N = s &&\pmod N\\
    j + (N - i) &= j - i &&\pmod N
    \end{align*}\]
</p>

<p>
Nå kan vi sjekke om \(0 < j - i \pmod N \leq s\), som er helt ekvivalent med
å sjekke om \(j\) er mellom \(i + 1\) og \(i + s\), men der vi slipper å ta høyde
for om \(j\) er større eller mindre enn \(i\).
</p>

<p>
Merk at en slik utregning (eller formulering) ikke er det vesentlige her.
Det vesentlige er at en nøkkel \(k\) kun kan brukes til å fylle et hull på
plass \(i\), dersom dens ideelle posisjon \(j\) ikke er mellom \(i+1\) og \(i +
    s\).
</p>
</div>
</div>

<div id="outline-container-orga377948" class="outline-4">
<h4 id="orga377948">Iterator</h4>
<div class="outline-text-4" id="text-orga377948">
<p>
Iteratoren for hashmapet kan skrives ved å gå gjennom arrayet, og gå
gjennom hver (ikke-tomme) bøtte, og gi hvert nøkkel-/verdipar. For å få en
iterator bruker vi <code>yield</code>.
</p>

<div class="org-src-container">
<pre class="src src-python" id="orga6862d3"><span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">__iter__</span>(<span style="color: #673AB7;">self</span>):
    <span style="color: #673AB7;">for</span> kv <span style="color: #673AB7;">in</span> <span style="color: #673AB7;">self</span>.A:
        <span style="color: #673AB7;">if</span> kv != <span style="color: #673AB7;">None</span>:
            <span style="color: #673AB7;">yield</span> kv
</pre>
</div>
</div>
</div>

<div id="outline-container-org20b71c7" class="outline-4">
<h4 id="org20b71c7">Minitest</h4>
<div class="outline-text-4" id="text-org20b71c7">
<p>
La oss sjekke om dette hashmapet faktisk kan holde på elementer slik vi
forventer. Vi nøyer oss med å mappe bokstavene <code>a</code>, <code>b</code>, <code>c</code> og <code>d</code>, til
henholdsvis <code>1</code>, <code>2</code>, <code>3</code> og <code>4</code>, og printer ut hashmapet mellom hver
operasjon.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #263238; font-weight: bold;">d</span> = LinearProbingMap()
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'a'</span>] = 0
<span style="color: #673AB7;">print</span>(d)
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'b'</span>] = 1
<span style="color: #673AB7;">print</span>(d)
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'c'</span>] = 2
<span style="color: #673AB7;">print</span>(d)
<span style="color: #263238; font-weight: bold;">d</span>[<span style="color: #90A4AE;">'d'</span>] = 3
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'a'</span>]
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'b'</span>]
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'c'</span>]
<span style="color: #673AB7;">print</span>(d)
<span style="color: #673AB7;">del</span> d[<span style="color: #90A4AE;">'d'</span>]
<span style="color: #673AB7;">print</span>(d)
</pre>
</div>

<pre class="example">
{a ↦ 0}
{b ↦ 1, a ↦ 0}
{b ↦ 1, c ↦ 2, a ↦ 0}
{b ↦ 1, c ↦ 2, a ↦ 0, d ↦ 3}
{b ↦ 1, c ↦ 2, d ↦ 3}
{c ↦ 2, d ↦ 3}
{d ↦ 3}
{}
</pre>


<p>
Det ser fint ut!
</p>

<div class="collapsible" id="org348f3b4">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;linear_probing_map&gt;&gt;
</pre>
</div>

</div>

<p>
Klikk på kodeblokken ovenfor for å se hele implementasjonen av hashmap med
linear probing.
</p>
</div>
</div>
</div>

<div id="outline-container-orge45a7a1" class="outline-2">
<h2 id="orge45a7a1">Testing</h2>
<div class="outline-text-2" id="text-orge45a7a1">
<blockquote>
<p>
Testing er ikke en del av pensum i IN2010, og denne seksjonen er mest for de
spesielt interesserte.
</p>
</blockquote>

<p>
For å teste hashmapimpementasjonene, kan vi bruke et bibliotek som heter
<a href="https://hypothesis.readthedocs.io/en/latest/">Hypothesis</a>. I stedet for å skrive mange tester for hånd, der vi prøver å
finne på mulige grensetilfeller, kan vi bruke Hypothesis til å generere
tester for oss. Dette kalles «property-based testing». Våre
hashmapimpementasjoner kan testes opp mot Python's innebygde <code>dict</code> siden de
skal støtte de samme operasjonene.
</p>

<p>
For hashmap ligger alle utfordringene i hvordan nøklene behandles. Verdiene
som lagres sammen med nøkkelen spiller ingen rolle for algoritmene, og derfor
er det logikken rund nøklene som har behov for testing.
</p>

<p>
Vi setter opp et enkelt testscenario:
</p>
<ul class="org-ul">
<li>Ta en liste med nøkler som input, der nøklene er heltall.</li>
<li>Sett inn hver nøkkel i hashmapet med verdi \(1\) (valgt vilkårlig).</li>
<li>Slett hver hver nøkkel fra hashmapet.</li>
</ul>
<p>
Vi gjør dette for en <code>SeparateChainingMap</code>, en <code>LinearProbingMap</code> og en
<code>dict</code>. Mellom hvert steg sjekker vi at alle hashmapene inneholder de samme
nøklene.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #673AB7;">import</span> hypothesis <span style="color: #673AB7;">as</span> hyp
<span style="color: #673AB7;">import</span> hypothesis.strategies <span style="color: #673AB7;">as</span> st

<span style="color: #673AB7;">@hyp.given</span>(st.lists(st.integers()))
<span style="color: #673AB7;">@hyp.settings</span>(max_examples=1000)
<span style="color: #673AB7;">def</span> <span style="color: #263238; font-weight: bold;">test_hashmaps</span>(keys):
    <span style="color: #263238; font-weight: bold;">ds</span> = SeparateChainingMap()
    <span style="color: #263238; font-weight: bold;">dl</span> = LinearProbingMap()
    <span style="color: #263238; font-weight: bold;">reference</span> = <span style="color: #673AB7;">dict</span>()

    <span style="color: #673AB7;">for</span> key <span style="color: #673AB7;">in</span> keys:
        <span style="color: #263238; font-weight: bold;">ds</span>[key] = 1
        <span style="color: #263238; font-weight: bold;">dl</span>[key] = 1
        <span style="color: #263238; font-weight: bold;">reference</span>[key] = 1
        <span style="color: #263238; font-weight: bold;">ds_ks</span> = <span style="color: #673AB7;">set</span>(k <span style="color: #673AB7;">for</span> k, v <span style="color: #673AB7;">in</span> ds)
        <span style="color: #263238; font-weight: bold;">dl_ks</span> = <span style="color: #673AB7;">set</span>(k <span style="color: #673AB7;">for</span> k, v <span style="color: #673AB7;">in</span> dl)
        <span style="color: #263238; font-weight: bold;">reference_ks</span> = <span style="color: #673AB7;">set</span>(reference.keys())
        <span style="color: #673AB7;">assert</span> ds_ks == dl_ks == reference_ks

    <span style="color: #673AB7;">for</span> key <span style="color: #673AB7;">in</span> keys:
        <span style="color: #673AB7;">del</span> ds[key]
        <span style="color: #673AB7;">del</span> dl[key]
        <span style="color: #673AB7;">if</span> key <span style="color: #673AB7;">in</span> reference_ks:
            <span style="color: #673AB7;">del</span> reference[key]
        <span style="color: #263238; font-weight: bold;">ds_ks</span> = <span style="color: #673AB7;">set</span>(k <span style="color: #673AB7;">for</span> k, v <span style="color: #673AB7;">in</span> ds)
        <span style="color: #263238; font-weight: bold;">dl_ks</span> = <span style="color: #673AB7;">set</span>(k <span style="color: #673AB7;">for</span> k, v <span style="color: #673AB7;">in</span> dl)
        <span style="color: #263238; font-weight: bold;">reference_ks</span> = <span style="color: #673AB7;">set</span>(reference.keys())
        <span style="color: #673AB7;">assert</span> ds_ks == dl_ks == reference_ks
</pre>
</div>

<p>
Etter vi har definert denne testfunksjonen (med litt Hypothesis-magi), får vi
en randomisert testfunksjon <code>test_hashmaps</code>. Når vi kaller på denne vil den
generere 1000 tester, som er langt flere enn vi ville klart å skrive for hånd.
</p>

<div class="org-src-container">
<pre class="src src-python">test_hashmaps()
</pre>
</div>

<p>
Hvis funksjonen kjører uten å klage, så betyr det at det ikke ble funnet noe
feil. Da kan vi være langt mer sikre på at denne implementasjonen er korrekt!
</p>

<blockquote>
<p>
Det er viktig å legge til at første gang koden ble testet, så ble det funnet
et moteksempel. Hypothesis genererte listen <code>[0, 1, 4]</code> som trigget en feil i
<code>__fill_hole</code> i linear probing. Feilen lå på siste linje, der <code>i</code> ble
inkrementert i stedet for <code>s</code>. Slike feil er fort gjort, og ikke alltid så lett
å finne. En ofte større utfordring er å finne en <i>liten</i> test som trigger
feilen. Hypothesis bruker strategier for å finne et så lite eksempel som
mulig.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org340d636" class="outline-2">
<h2 id="org340d636">En uformell kjøretidsanalyse</h2>
<div class="outline-text-2" id="text-org340d636">
<p>
Ved å gjøre en ordinær kjøretidsanalyse vil vi se på hvor mange steg
algoritmene vil bruke under verst tenkelige omstendigheter (altså, en verste
tilfelle analyse). Hvis vi gjør det for separate chaining og linear probing,
så er det ganske enkelt å se at alle operasjoner har \(O(n)\) kjøretid, der \(n\)
er antall elementer i datastrukturen. Det er tilstrekkelig å anta at alle \(n\)
elementer hasher til samme posisjon; for separate chaining vil det bety at vi
essesielt har implementert hashmaps som en lenket liste; for linear probing
betyr det at vi essensielt har implementert et hashmap som et uordnet array
(som dynamisk øker størrelsen på arrayet ved behov).
</p>

<p>
Allikevel påstår vi at hashmaps er en <i>svært effektiv</i> implementasjon av
mappinger (og mengder). Den eneste måten det kan stemme på er at en verste
tilfelle analyse med store \(O\)-notasjon ikke alltid gir et fullstendig
bilde. Det har vi også prøvd å formidle: Store \(O\)-notasjon gir <i>ofte</i> en
god indikasjon på om en algoritme er effektiv eller ikke, men notasjonen lar
oss også abstrahere vekk detaljer som <i>kan</i> være vesentlige.
</p>

<p>
For å gjøre en formell analyse av datastrukturer som bruker hashing snakker
man ofte om <i>forventet amortisert</i> tid. Å utføre formelle analyser som dette er
utenfor pensum i IN2010, men vi skal nå en forståelse av hva det betyr på et
overordnet nivå.
</p>

<p>
Det verste tilfellet for alle operasjoner kan lett fremprovoseres ved å velge
en forferdelig dårlig hashfunksjon; det kan også fremprovoseres med en god
hashfunksjon og helt vanvittig uflaks. Men vi har sett at vi kan lage
hashfunksjoner som distribuerer svært godt, så la oss heller anta at vi har
en god hashfunksjon og at nøklene vi skal lagre er tilfeldig distribuert.
</p>

<p>
Da har vi at sjansen for at en nøkkel \(k\) hasher til \(i\) er \(\frac{1}{N}\)
(altså er det like stor sjanse for at \(k\) hasher til \(i\) som til alle andre
posisjoner). Sjansen for at vi har mange nøkler \(k_1, k_2, \dots, k_n\) som
alle hasher til \(i\) blir \(\overbrace{\frac{1}{N} \cdot \frac{1}{N} \cdots
  \frac{1}{N}}^n = (\frac{1}{N})^n\). Dette tallet blir <i>veldig</i> lite <i>veldig</i> fort,
som er en annen måte å si at sjansen for at dette skjer er forsvinnende
liten.
</p>

<p>
Generelt så er sjansen for kollisjoner liten så lenge det er god plass i
arrayet; ethvert som arrayet fylles opp, så er sjansen for kollisjon stor,
men sjansen for at kollisjonene oppstår på de samme posisjonene er fremdeles
liten. Med andre ord kan vi bruke statistiske metoder for å gi svært gode
argumenter for at listene i separate chaining vil være svært korte, og for
linear probing er avstanden mellom der en nøkkel hashes til og posisjonen den
lagres på er svært kort (og reduseres til en konstant hvis setter en
begrensning på load factoren). Det siste som gjenstår for å forstå hvorfor
hashmaps er raske, er å snakke om rehashing.
</p>

<p>
Når arrayet blir for fullt gjør vi en rehash, altså konstruerer et nytt array
og setter inn alle elementene på nytt. Dette er jo definitivt lineær tid! Det
er ingen måte å argumentere for at vi kan slippe unna med noe lavere enn det.
Siden vi vil ha kall på <i>insert</i> som bruker lineær tid, vil igjen en verste
tilfelle analyse tilsi at innsetting i hashmaps er i \(O(n)\).
</p>

<p>
En amortisert analyse ber deg heller ta følgende perspektiv: Ja, vi har et
lineært antall operasjoner som må gjøres hver gang arrayet blir dobblet så
stort. Anta nå at det krever \(c \cdot n\) operasjoner for en rehashing, der \(c\) er
en konstant. Men hva hvis vi heller sier at hvert av kallene som ledet opp
til fordoblingen <i>deler</i> på resursene som brukes på å gjennomføre en rehash.
Det er ca. \(n\) kall på <i>insert</i> som ledet til fordoblingen, så hva hvis hvert
av de kallene gjorde \(c\) flere operasjoner enn de opprinnelig gjorde? Jo, da
hadde de gjort et <i>konstant</i> antall flere operasjoner, og fra store \(O\) analyse
kjenner vi at \(O(1 + c) = O(1)\) når \(c\) er en konstant. Altså vil hvert av
kallene på insert fremdeles være i konstant tid!
</p>

<p>
En viktig konsekvens av dette er at en innsetting i et hashmap vil være
ineffektiv en sjelden gang, og det blir sjeldnere og sjeldnere ettersom
antall elementer vokser. For noen applikasjoner kan dette være vesentlig; i
et spill for eksempel, kan en rehash kan føre til at ting stopper opp i et
lite øyeblikk. I slike settinger kan det kanskje være bedre å heller bruke en
trestruktur (som AVL eller rød-svarte trær), som kanskje er tregere i sum,
men er til gjengjeld <i>jevn</i>.
</p>

<p>
For å oppsummere kan vi si at alle operasjoner for hashmaps har \(O(n)\) i en
verste tilfelle kjøretidsanalyse. Men ved å anta en god hashfunsjon får vi at
<i>gjennomsnittlig</i> er hver operasjon i \(O(1)\), med unntak av kall som fører til
rehashing. Hvis vi videre tenker at vi kan fordele ressursbruken på alle
kallene som leder til en rehashing, så får vi gjennomsnittlig \(O(1)\)
<i>amortisert</i> kjøretidskompleksitet på alle operasjoner.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Fotnoter: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Faktisk er en funksjon og en mapping akkurat det samme:
</p>
<ul class="org-ul">
<li>en funksjon tar et input og returnerer et output;</li>
<li>en annen måte å si det samme er at vi relaterer et input til et output;</li>
<li>som igjen er det samme som at vi assosierer et input til et output;</li>
<li>som igjen er det samme som at vi assosierer en nøkkel til en verdi.</li>
</ul>
<p class="footpara">
Vi bruker litt ulike begreper avhengig av hva det er vi ønsker å formidle. For
funksjoner er det vanlig at vi har en effektiv måte å <i>beregne</i> hva output skal
være for et gitt input. For mappinger er det vanligere at vi eksplisitt lister
opp hva som skal assosieres til hva, slik vi gjør når vi putter ting inn i et
hashmap.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Python støtter ikke hashing av <i>muterbare</i> datastrukturer, som lister og
ordbøker. Det er fordi hashen bestemmes av verdiene i datastrukturen, som gjør
at de ikke kan ha en stabil hash over tid.
</p></div></div>


</div>
</div></div>
</body>
</html>